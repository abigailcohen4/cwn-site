import{fU as R,fV as w,e as x,fW as z,fX as j,fY as b,aH as I,aF as P,j as v,aG as A}from"./index-DHOd0012.js";import{execute as Z}from"./affineTransformOperator-qr13CSRe.js";import k from"./Transformation-S_I94Un7.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Transformation2D-CJmlXOyD.js";import"./apiConverter-4-E83tby.js";import"./ProjectionTransformation-JG_vlzn4.js";import"./jsonConverter-lHviFLeK.js";function E({edits:t,geometry:n,mode:r,relationships:l,rotation:o,tag:i="",template:e}){const{definition:a}=e,s=n.x-a.origin.x,u=n.y-a.origin.y,d=a.origin.hasZ&&n.hasZ?n.z-a.origin.z:0,g=M(a.origin.clone(),s,u,d),p=new k().rotate(o,g.x,g.y);for(const y of a.parts){if(t.length>R&&r==="digitizing")break;const f=y.template;if(!w(f))throw new x("shared-template:template-not-loaded","A template part's template must be loaded before use");if(z(f)){let h=M(y.geometry,s,u,d);p.isIdentity||(h=Z(h,p)),j({edits:t,geometry:h,relationships:l,tag:i,template:f})}else if(b(f)){const h=[];if(E({edits:p.isIdentity?h:t,geometry:n,mode:r,relationships:l,rotation:0,tag:i,template:f}),!p.isIdentity)for(const c of h){const{geometry:m}=c.graphic;m&&m.type!=="mesh"&&(c.graphic.geometry=Z(m,p),t.push(c))}}}return g}function M(t,n,r,l=0){if(!t)return null;if(t.type==="point")return new I({spatialReference:t.spatialReference,x:t.x+n,y:t.y+r,...t.hasZ?{z:t.z+l}:{},...t.hasM?{m:t.m}:{}});if(t.type==="multipoint"){const o=[];if(t.hasZ&&t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];o.push([e[0]+n,e[1]+r,e[2]+l,e[3]])}else if(t.hasZ)for(let i=0;i<t.points.length;i++){const e=t.points[i];o.push([e[0]+n,e[1]+r,e[2]+l])}else if(t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];o.push([e[0]+n,e[1]+r,e[2]])}else for(let i=0;i<t.points.length;i++){const e=t.points[i];o.push([e[0]+n,e[1]+r])}return new P({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:o})}if(t.type==="polygon"){const o=new v({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.rings.length;i++){const e=t.rings[i],a=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]+l,e[s][3]]);else if(t.hasM)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]]);else if(t.hasZ)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]+l]);else for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r]);o.addRing(a)}return o}if(t.type==="polyline"){const o=new A({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.paths.length;i++){const e=t.paths[i],a=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]+l,e[s][3]]);else if(t.hasZ)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]+l]);else if(t.hasM)for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r,e[s][2]]);else for(let s=0;s<e.length;s++)a.push([e[s][0]+n,e[s][1]+r]);o.addPath(a)}return o}return t.clone()}export{E as createPresetServiceEdit,M as translate};
