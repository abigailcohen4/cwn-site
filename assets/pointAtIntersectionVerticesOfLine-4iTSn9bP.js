import{b as k,y as q,j as z,g as C,m as F,f as U}from"./builderUtils-JmZg6UOz.js";import{u as v}from"./offsetUtils-DOKhq-qt.js";import{m as x,u as P,g as A,x as G,M as H}from"./shapeUtils-CHwYDJ-V.js";import{g8 as Q,fU as B,aF as D}from"./index-BZBPR1M1.js";import{n as E}from"./intersectsOperator-CT4EwHuP.js";import{fromSpatialReference as I}from"./apiConverter-C3eUN7VO.js";import"./createPresetServiceEdit-CDf1cxqv.js";import"./affineTransformOperator-Bq1AeYd6.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Transformation2D-CJmlXOyD.js";import"./Transformation-BweWtuHR.js";import"./ProjectionTransformation-Cpn_hruU.js";import"./jsonConverter-BRds9OlZ.js";import"./offsetOperator-DVV0hmwt.js";import"./operatorOffset-Bo_6juX_.js";import"./OperatorIntersects-CNEch0sT.js";function lt(s){if(L(s)&&s.mode!=="digitizing")return J(s)}async function J({templatePart:s,parentTemplate:a,shape:p,edits:f,relationships:S,mode:T}){var $;const{builderConfig:l}=s,i=k(l),g=q(l),V=z(l),c=C(l,g),t=V||i===0?p:v(p,i);if(t===null)return;const o=a.layer.createQuery();o.geometry=t,o.spatialRelationship="intersects",o.returnM=!0,o.returnZ=!0,o.outSpatialReference=t.spatialReference,o.cacheHint=!1,o.returnGeometry=!0,o.historicMoment=a.layer.historicMoment,o.gdbVersion=a.layer.gdbVersion;const j=2*((($=I(t.spatialReference))==null?void 0:$.getTolerance())??.001);o.distance=j;const{features:y}=await a.layer.queryFeatures(o);if(y.length===0)return;const d=[];for(const e of y)d.push(K(e.geometry));const h=F(t);let R=0,b=0;for(let e=0;e<t.paths.length&&!(f.length>B);e++){const u=t.paths[e].length;for(let r=0;r<u;r++){let n=t.getPoint(e,r);if(n!=null){for(const w of d)if(E(n,w)){if(r>0&&c!==0&&(R+=t.hasZ?x(t.paths[e][r-1],t.paths[e][r],h):P(t.paths[e][r-1],t.paths[e][r])),c!==0){let M=1;if(g){const m=c<0?r-1:r+1;if(m>=u||m<0)return;M=t.hasZ?x(t.paths[e][r],t.paths[e][m],h):P(t.paths[e][r],t.paths[e][m])}const Z=R+M*c;n=t.hasZ?A(t,Z,i,h):G(t,Z,i)}else i!==0&&(n=H(n,r===u-1?[t.paths[e][r-1],t.paths[e][r]]:[t.paths[e][r],t.paths[e][r+1]],i));n&&U({templatePart:s,shape:n,edits:f,relationships:S,mode:T},`V${b.toString()}`);break}b++}}}}function K(s){const a=[];for(const p of s.paths)for(const f of p)a.push([...f]);return new D({spatialReference:s.spatialReference,points:a})}function L(s){return s.parentTemplate!=null&&Q(s.shape)}const ct=!0;export{lt as execute,ct as isAsync};
