import{jD as f,jE as b,jF as q,jG as C,c7 as h,cb as g,c6 as R,jH as k,jI as v,jJ as y,jK as M,cN as x,jL as A,jM as D}from"./index-D128Jkh1.js";import{geodesicArea as F}from"./geometryEngine-BQtXtCxK.js";import{r as J}from"./geodesicLengthMeasurementUtils-uXJo9PQ7.js";import{l as W}from"./quantityFormatUtils-21Uh15DF.js";function B(n){const{spatialReference:e}=n;return J(e,w,E,n)}function w(n){return f(Math.abs(b([n],"square-meters")[0]),"square-meters")}function E(n){try{return f(Math.abs(F(n,"square-meters")),"square-meters")}catch{return null}}function P(n,e=K()){return G(n,e,!1)}function G(n,e,o=n.hasZ){const a=W(n.spatialReference),u=C(a);if(u==null)return null;const $=(c,s)=>!(s.length<2)&&(g(c,s[0],s[1],o&&s[2]||0),!0);let j=0;for(const c of n.rings){const s=c.length;if(s<3)continue;const{positionsWorldCoords:r}=e;for(;r.length<s;)r.push(h());const m=H,l=g(I,0,0,0),d=1/s;for(let t=0;t<s;t++){if(!$(m,c[t])||!R(m,n.spatialReference,r[t],a))return null;k(l,l,r[t],d)}const p=v(r[0],r[1],l,y());if(M(x(p))===0)continue;for(let t=0;t<s;t++)A(p,l,r[t],r[t]);const i=L(r);for(let t=0;t<i.length;t+=3)j+=D(r[i[t]],r[i[t+1]],r[i[t+2]])}return f(j,u)}const H=h(),I=h();function K(){return{positionsWorldCoords:[]}}function L(n){return q(N(n),[],2)}function N(n){const e=new Float64Array(2*n.length);for(let o=0;o<n.length;++o){const a=n[o],u=2*o;e[u]=a[0],e[u+1]=a[1]}return e}export{L as U,P as j,K as k,B as o};
